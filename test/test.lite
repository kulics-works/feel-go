"webkit" {
	"reflect"
	"strings"

	"github.com/gin-gonic/gin"
}

# Context 类型别名 #
Context => ?gin.Context

# WebServer web服务辅助工具 #
WebServer -> {
	listen: Str
	engine: ?gin.Engine
}

# NewWebServerDefault 构建web服务数据对象,domain可以为空 #
NewWebServerDefault(listen: Str -> v: ?WebServer) {
	srv := WebServer{}?
	srv.listen = listen
	srv.engine = gin.Default()
	<- srv
}

# Run 运行web服务 #
me: ?WebServer -> {	
	Run(-> e:error) {
		<- me.engine.Run(me.listen)
	}
	# Handle_Func 监听函数 #
	HandleFunc(method: Method, relativePath: Str, handle: (Context->) -> v: ?WebServer) {
		method ? GET {
			me.engine.GET(relativePath, handle)
		} POST {
			me.engine.POST(relativePath, handle)
		} PUT {
			me.engine.PUT(relativePath, handle)
		} DELETE {
			me.engine.DELETE(relativePath, handle)
		} PATCH {
			me.engine.PATCH(relativePath, handle)
		} OPTIONS {
			me.engine.OPTIONS(relativePath, handle)
		}
		<- me
	}
	# HandleGET 监听Get #
	HandleGET(relativePath: Str, handle:(Context->) -> v: ?WebServer) {
		<- me.HandleFunc(GET, relativePath, handle)
	}
	# HandlePOST 监听Post #
	HandlePOST(relativePath: Str, handle:(Context->) -> v: ?WebServer)  {
		<- me.HandleFunc(POST, relativePath, handle)
	}
	# HandlePUT 监听Put #
	HandlePUT(relativePath: Str, handle:(Context->) -> v: ?WebServer)  {
		<- me.HandleFunc(PUT, relativePath, handle)
	}
	# HandleDELETE 监听Delete #
	HandleDELETE(relativePath: Str, handle:(Context->) -> v: ?WebServer)  {
		<- me.HandleFunc(DELETE, relativePath, handle)
	}
	# HandlePATCH 监听Patch #
	HandlePATCH(relativePath: Str, handle:(Context->) -> v: ?WebServer)  {
		<- me.HandleFunc(PATCH, relativePath, handle)
	}
	# HandleOPTIONS 监听Options #
	HandleOPTIONS(relativePath: Str, handle:(Context->) -> v: ?WebServer)  {
		<- me.Handle_Func(OPTIONS, relativePath, handle)
	}
	# HandleStruct 监听结构体，反射街头的http方法以及遍历每个字段的http方法，实现REST形式的API服务
	结构体的方法必须与 Method 类型的名称一致 #
	HandleStruct(relativePath: Str, handle: Any -> v: ?WebServer) {
		me.handleStruct(relativePath, handle)
		<- me
	}
	# handleStruct 使用反射遍历结构体的方法和字段，对http方法进行注册 # 
	handleStruct(relativePath: Str, handle: Any ->) {
		rfType := reflect.TypeOf(handle)
		rfValue := reflect.ValueOf(handle)
		# 只接受结构体、接口及指针 #
		rfType.Kind() ? reflect.Ptr, reflect.Interface, reflect.Struct {
			# 反射方法 #
			[0 < rfType.NumMethod()] @ i {
				methodName := rfType.Method(i).Name
				? ~isMethod(NewMethod(methodName)) {
					-> @
				}
				handleFunc := (ctx:Context ->) {
					rfValue.MethodByName(methodName).Call([]reflect.Value{reflect.ValueOf(ctx)})
				}
				me.HandleFunc(NewMethod(methodName), relativePath, handleFunc)
			}
			# 反射字段 #
			[0 < rfType.NumField()] @ i {
				fieldName := rfType.Field(i).Name
				me.handleStruct(relativePath+"/"+strings.ToLower(fieldName[<1])+fieldName[1<=],
					rfValue.FieldByName(fieldName).Interface())
			}
		}
	}
}
